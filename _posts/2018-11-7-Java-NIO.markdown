---
layout:         post
title:     		NIO
author:     	YY
tag:            io
subtitle:    	
excerpt_separator: ""
dataset:    /projectors/data.json
---

<h1>用nio实现客户端和服务端的通信</h1>
<hr>

<h3>服务端chatServer</h3>
{% highlight ruby %}
package NIO.ServerSocket.Demo;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

/**
 * create by yang yin on 2018/
 */
public class ChatServer {


    public static void main(String[] args)throws IOException {
        ServerSocketChannel channel = ServerSocketChannel.open();
        channel.socket().bind(new InetSocketAddress("127.0.0.1",2345));
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        channel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            //查看当前是否有注册好的通道,如果没有则等待timeout秒之后继续检测
            int num = selector.select(500);
            if (num == 0) {
                continue;
            }
            Set<SelectionKey> sets = selector.selectedKeys();

            Iterator<SelectionKey> it = sets.iterator();
            while (it.hasNext()) {

                SelectionKey key = it.next();

                if (key.isAcceptable()) {//注册到select

                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                    SocketChannel socketChannel=serverSocketChannel.accept();//接受与此频道套接字的连接,获取客户端
                    socketChannel.configureBlocking(false);//修改为非阻塞
                    socketChannel.register(selector, SelectionKey.OP_READ,ByteBuffer.allocate(1024));//注册客户端到selector

                } else if (key.isConnectable()) {

                    SocketChannel channelConnected = (SocketChannel) key.channel();
                    System.out.println(channelConnected.getLocalAddress() + "has connected");

                } else if (key.isWritable()) {

                    SocketChannel channelWrite = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();

                    buffer.flip();

                    while (buffer.hasRemaining()) {
                        channelWrite.write(buffer);
                    }

                    buffer.compact();//将所有未读数据拷贝到buffer起始处

                } else if (key.isReadable()) {

                    SocketChannel channelRead = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    int byteCount=channelRead.read(buffer);
                    while (byteCount>0){
                        buffer.flip();//反转
                        System.out.println(new String(buffer.array()));
                        byteCount=channelRead.read(buffer);
                    }

                    }

                }
                it.remove();
            }
        }

    }


{% endhighlight ruby %}



 
<br>

 
     
<h3>客户端ChatClient</h3>
{% highlight ruby %}
package NIO.ServerSocket.Demo;

import java.io.IOError;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Scanner;

/**
 * create by yang yin on 2018/
 */
public class ChatClient {


    public static void main(String[] args)throws IOException {
        SocketChannel socketChannel=SocketChannel.open();
        socketChannel.connect(new InetSocketAddress("127.0.0.1",2345));
        Scanner sc=new Scanner(System.in);
        ByteBuffer byteBuffer=ByteBuffer.allocate(1024);
        if(socketChannel.finishConnect()){
            while (true){
                String word=sc.nextLine();
                byteBuffer.clear();
                byteBuffer.put(word.getBytes());
                byteBuffer.flip();
                while (byteBuffer.hasRemaining()){
                    socketChannel.write(byteBuffer);
                   
                }
            }
        }
    }


}


{% endhighlight ruby %}



 
<br>










